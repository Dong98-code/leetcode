## 2. 函数提升

```js
foo();
var foo;
function foo(){
  console.log(1);
}
foo = function(){
  console.log(2);
}
```
输出：`1`
解释：
函数提升：
只提升 函数声明，而不会提升函数表达式

## 5. promise.finally

```js
const p1 = new Promise((resolve) => {
  setTimeout(() => {
    resolve('resolve3');
    console.log('timer1')
  }, 0)
  resolve('resovle1');
  resolve('resolve2');
}).then(res => {
  console.log(res)
  setTimeout(() => {
    console.log(p1)
  }, 1000)
}).finally(res => {
  console.log('finally', res)
})

```
输出：
'resolve1'
'finally' undefined
'timer1'
Promise{<resolved>: undefined}

解释：
![20220729225241](https://xd-imgsubmit.oss-cn-beijing.aliyuncs.com/images/20220729225241.png)

## 6. 

```js
const async1 = async () => {
  console.log('async1');
  setTimeout(() => {
    console.log('timer1')
  }, 2000)
  await new Promise(resolve => {
    console.log('promise1')
  })
  console.log('async1 end')
  return 'async1 success'
} 
console.log('script start');
async1().then(res => console.log(res));
console.log('script end');
Promise.resolve(1)
  .then(2)
  .then(Promise.resolve(3))
  .catch(4)
  .then(res => console.log(res))
setTimeout(() => {
  console.log('timer2')
}, 1000)

```
结果：
![20220731110048](https://xd-imgsubmit.oss-cn-beijing.aliyuncs.com/images/20220731110048.png)
解析：
await 紧跟在后面的语句立即执行，下面的语句会成为一个微任务， 当 await的结果为 真或者是 resolved之后执行，如果后面跟着一个pending状态的promise，那么后面的微任务就会一直不执行
![20220731110249](https://xd-imgsubmit.oss-cn-beijing.aliyuncs.com/images/20220731110249.png)