## 343.整数分解
### 题目链接：
[343.整数拆分](https://leetcode-cn.com/problems/integer-break/)
### 题目描述

给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。
```
示例 1:

输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。

```

```
示例 2:

输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
```


### 思路

1.动态规划

使用长度为n+1的dp数组，`dp[i]`表示正整数i 的 **经过拆分**得到的最大值，则`dp[-1]`即为所求

初始条件：
`dp[1]=1`，`dp[0]`等于什么无所谓,方正用不到

转移方程：
求解dp[i]，那么会用到它之前的数，`dp[1]...dp[i-1]`,这也是使用动态规划的原因之一
求解方法时，遍历整数i 的分解情况，例如 9：遍历，18，2 7；3，6；4，5;这几种情况，计算这样分解的乘积的最大值

在这个给过程中要判断 是否可以再分解以使得乘积最大，例如 3： 分解得到的最大值为2，不分解则可以 \*3，因此再这个过程中要判断分解过后的值与他本身相比 是否可以提供更大的成书
max(j,dp[j])


### code:
```
class Solution:
    def integerBreak(self, n: int) -> int:
        dp = [1]*(n+1)
        for i in range(2,n+1):
            max_num = 1
            for j in range(1,i//2+1):
                max_num = max(max_num, max(j,dp[j-1])*max(i-j,dp[i-j]))
            dp[i] = max_num
        
        return dp[-1]
```

